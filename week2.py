# -*- coding: utf-8 -*-
"""lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hkKG0B7S4N4V2PIg7B8bYLsR5YElvF0C
"""

from collections import deque

# Define possible moves
MOVES = {
    'Up': -3,
    'Down': 3,
    'Left': -1,
    'Right': 1
}

def is_valid_move(zero_index, move):
    if move == 'Left' and zero_index % 3 == 0:
        return False
    if move == 'Right' and zero_index % 3 == 2:
        return False
    if move == 'Up' and zero_index < 3:
        return False
    if move == 'Down' and zero_index > 5:
        return False
    return True

def move_tile(state, move):
    zero_index = state.index('0')
    if not is_valid_move(zero_index, move):
        return None
    new_index = zero_index + MOVES[move]
    state_list = list(state)
    state_list[zero_index], state_list[new_index] = state_list[new_index], state_list[zero_index]
    return ''.join(state_list)

def reconstruct_path(parent, move_record, end_state):
    path = []
    current = end_state
    while parent[current] is not None:
        path.append((move_record[current], current))
        current = parent[current]
    path.reverse()
    return path

# BFS implementation
def bfs(start_state, goal_state):
    queue = deque()
    visited = set()
    parent = {}
    move_record = {}

    queue.append(start_state)
    visited.add(start_state)
    parent[start_state] = None
    move_record[start_state] = None

    while queue:
        current = queue.popleft()

        if current == goal_state:
            return reconstruct_path(parent, move_record, current)

        for move in MOVES:
            new_state = move_tile(current, move)
            if new_state and new_state not in visited:
                visited.add(new_state)
                queue.append(new_state)
                parent[new_state] = current
                move_record[new_state] = move

    return None

# DFS implementation
def dfs(start_state, goal_state, max_depth=50):
    stack = [(start_state, 0)]
    visited = set()
    parent = {}
    move_record = {}

    parent[start_state] = None
    move_record[start_state] = None

    while stack:
        current, depth = stack.pop()

        if current == goal_state:
            return reconstruct_path(parent, move_record, current)

        if depth >= max_depth:
            continue

        visited.add(current)

        for move in reversed(list(MOVES)):  # Reverse for consistent DFS order
            new_state = move_tile(current, move)
            if new_state and new_state not in visited:
                stack.append((new_state, depth + 1))
                parent[new_state] = current
                move_record[new_state] = move

    return None

def print_puzzle(state):
    for i in range(0, 9, 3):
        row = state[i:i+3]
        print(' '.join(c if c != '0' else '_' for c in row))
    print()

def print_solution(start_state, goal_state, method='bfs'):
    print(f"\nStart State ({method.upper()}):")
    print_puzzle(start_state)
    print("Goal State:")
    print_puzzle(goal_state)

    if method == 'bfs':
        path = bfs(start_state, goal_state)
    elif method == 'dfs':
        path = dfs(start_state, goal_state)
    else:
        raise ValueError("Method must be 'bfs' or 'dfs'")

    if path is None:
        print("No solution found.")
        return

    print(f"\nSolution found in {len(path)} moves:")
    current = start_state
    for move, state in path:
        print(f"Move: {move}")
        print_puzzle(state)

def get_state_input(prompt):
    while True:
        raw = input(prompt).replace(" ", "").replace("_", "0")
        if len(raw) != 9 or not all(c in "0123456789" for c in raw):
            print("Invalid input. Enter 9 digits from 0-8 (0 for blank).")
            continue
        if sorted(raw) != list("012345678"):
            print("Invalid puzzle: must contain digits 0 through 8 exactly once.")
            continue
        return raw

# Main program
if __name__ == "__main__":
    print("8-Puzzle Solver (BFS and DFS)")
    print("Enter the puzzle state as 9 digits (0 = blank). Example: 123405678")

    start = get_state_input("Enter the initial state: ")
    goal = get_state_input("Enter the goal state: ")

    method = ''
    while method not in ['bfs', 'dfs']:
        method = input("Choose search method (bfs/dfs): ").strip().lower()

    print_solution(start, goal, method)

from collections import deque

# Define possible moves
MOVES = {
    'Up': -3,
    'Down': 3,
    'Left': -1,
    'Right': 1
}

def is_valid_move(zero_index, move):
    if move == 'Left' and zero_index % 3 == 0:
        return False
    if move == 'Right' and zero_index % 3 == 2:
        return False
    if move == 'Up' and zero_index < 3:
        return False
    if move == 'Down' and zero_index > 5:
        return False
    return True

def move_tile(state, move):
    zero_index = state.index('0')
    if not is_valid_move(zero_index, move):
        return None
    new_index = zero_index + MOVES[move]
    state_list = list(state)
    state_list[zero_index], state_list[new_index] = state_list[new_index], state_list[zero_index]
    return ''.join(state_list)

def reconstruct_path(parent, move_record, end_state):
    path = []
    current = end_state
    while parent[current] is not None:
        path.append((move_record[current], current))
        current = parent[current]
    path.reverse()
    return path

# BFS implementation
def bfs(start_state, goal_state):
    queue = deque()
    visited = set()
    parent = {}
    move_record = {}

    queue.append(start_state)
    visited.add(start_state)
    parent[start_state] = None
    move_record[start_state] = None

    while queue:
        current = queue.popleft()

        if current == goal_state:
            return reconstruct_path(parent, move_record, current)

        for move in MOVES:
            new_state = move_tile(current, move)
            if new_state and new_state not in visited:
                visited.add(new_state)
                queue.append(new_state)
                parent[new_state] = current
                move_record[new_state] = move

    return None

# DFS implementation
def dfs(start_state, goal_state, max_depth=50):
    stack = [(start_state, 0)]
    visited = set()
    parent = {}
    move_record = {}

    parent[start_state] = None
    move_record[start_state] = None

    while stack:
        current, depth = stack.pop()

        if current == goal_state:
            return reconstruct_path(parent, move_record, current)

        if depth >= max_depth:
            continue

        visited.add(current)

        for move in reversed(list(MOVES)):  # Reverse for consistent DFS order
            new_state = move_tile(current, move)
            if new_state and new_state not in visited:
                stack.append((new_state, depth + 1))
                parent[new_state] = current
                move_record[new_state] = move

    return None

def print_puzzle(state):
    for i in range(0, 9, 3):
        row = state[i:i+3]
        print(' '.join(c if c != '0' else '_' for c in row))
    print()

def print_solution(start_state, goal_state, method='bfs'):
    print(f"\nStart State ({method.upper()}):")
    print_puzzle(start_state)
    print("Goal State:")
    print_puzzle(goal_state)

    if method == 'bfs':
        path = bfs(start_state, goal_state)
    elif method == 'dfs':
        path = dfs(start_state, goal_state)
    else:
        raise ValueError("Method must be 'bfs' or 'dfs'")

    if path is None:
        print("No solution found.")
        return

    print(f"\nSolution found in {len(path)} moves:")
    current = start_state
    for move, state in path:
        print(f"Move: {move}")
        print_puzzle(state)

def get_state_input(prompt):
    while True:
        raw = input(prompt).replace(" ", "").replace("_", "0")
        if len(raw) != 9 or not all(c in "0123456789" for c in raw):
            print("Invalid input. Enter 9 digits from 0-8 (0 for blank).")
            continue
        if sorted(raw) != list("012345678"):
            print("Invalid puzzle: must contain digits 0 through 8 exactly once.")
            continue
        return raw

# Main program
if __name__ == "__main__":
    print("8-Puzzle Solver (BFS and DFS)")
    print("Enter the puzzle state as 9 digits (0 = blank). Example: 123405678")

    start = get_state_input("Enter the initial state: ")
    goal = get_state_input("Enter the goal state: ")

    method = ''
    while method not in ['bfs', 'dfs']:
        method = input("Choose search method (bfs/dfs): ").strip().lower()

    print_solution(start, goal, method)